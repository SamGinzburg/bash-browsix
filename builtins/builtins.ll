; ModuleID = 'builtins.c'
source_filename = "builtins.c"
target datalayout = "e-p:32:32-i64:64-v128:32:128-n32-S128"
target triple = "asmjs-unknown-emscripten"

%struct.builtin = type { i8*, i32 (%struct.word_list*)*, i32, i8**, i8*, i8* }
%struct.word_list = type { %struct.word_list*, %struct.word_desc* }
%struct.word_desc = type { i8*, i32 }

@.str = private unnamed_addr constant [6 x i8] c"alias\00", align 1
@.str.1 = private unnamed_addr constant [31 x i8] c"alias [-p] [name[=value] ... ]\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"unalias\00", align 1
@.str.3 = private unnamed_addr constant [29 x i8] c"unalias [-a] name [name ...]\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"bind\00", align 1
@.str.5 = private unnamed_addr constant [148 x i8] c"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]\00", align 1
@.str.6 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.7 = private unnamed_addr constant [10 x i8] c"break [n]\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"continue\00", align 1
@.str.9 = private unnamed_addr constant [13 x i8] c"continue [n]\00", align 1
@.str.10 = private unnamed_addr constant [8 x i8] c"builtin\00", align 1
@.str.11 = private unnamed_addr constant [34 x i8] c"builtin [shell-builtin [arg ...]]\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"caller\00", align 1
@.str.13 = private unnamed_addr constant [14 x i8] c"caller [expr]\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"cd\00", align 1
@.str.15 = private unnamed_addr constant [29 x i8] c"cd [-L|[-P [-e]] [-@]] [dir]\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"pwd\00", align 1
@.str.17 = private unnamed_addr constant [10 x i8] c"pwd [-LP]\00", align 1
@.str.18 = private unnamed_addr constant [2 x i8] c":\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.20 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.21 = private unnamed_addr constant [8 x i8] c"command\00", align 1
@.str.22 = private unnamed_addr constant [33 x i8] c"command [-pVv] command [arg ...]\00", align 1
@.str.23 = private unnamed_addr constant [8 x i8] c"declare\00", align 1
@.str.24 = private unnamed_addr constant [48 x i8] c"declare [-aAfFgilnrtux] [-p] [name[=value] ...]\00", align 1
@.str.25 = private unnamed_addr constant [8 x i8] c"typeset\00", align 1
@.str.26 = private unnamed_addr constant [46 x i8] c"typeset [-aAfFgilnrtux] [-p] name[=value] ...\00", align 1
@.str.27 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.28 = private unnamed_addr constant [32 x i8] c"local [option] name[=value] ...\00", align 1
@.str.29 = private unnamed_addr constant [5 x i8] c"echo\00", align 1
@.str.30 = private unnamed_addr constant [22 x i8] c"echo [-neE] [arg ...]\00", align 1
@.str.31 = private unnamed_addr constant [7 x i8] c"enable\00", align 1
@.str.32 = private unnamed_addr constant [45 x i8] c"enable [-a] [-dnps] [-f filename] [name ...]\00", align 1
@.str.33 = private unnamed_addr constant [5 x i8] c"eval\00", align 1
@.str.34 = private unnamed_addr constant [15 x i8] c"eval [arg ...]\00", align 1
@.str.35 = private unnamed_addr constant [8 x i8] c"getopts\00", align 1
@.str.36 = private unnamed_addr constant [29 x i8] c"getopts optstring name [arg]\00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"exec\00", align 1
@.str.38 = private unnamed_addr constant [65 x i8] c"exec [-cl] [-a name] [command [arguments ...]] [redirection ...]\00", align 1
@.str.39 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str.40 = private unnamed_addr constant [9 x i8] c"exit [n]\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"logout\00", align 1
@.str.42 = private unnamed_addr constant [11 x i8] c"logout [n]\00", align 1
@.str.43 = private unnamed_addr constant [3 x i8] c"fc\00", align 1
@.str.44 = private unnamed_addr constant [65 x i8] c"fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]\00", align 1
@.str.45 = private unnamed_addr constant [5 x i8] c"hash\00", align 1
@.str.46 = private unnamed_addr constant [42 x i8] c"hash [-lr] [-p pathname] [-dt] [name ...]\00", align 1
@.str.47 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@.str.48 = private unnamed_addr constant [26 x i8] c"help [-dms] [pattern ...]\00", align 1
@.str.49 = private unnamed_addr constant [8 x i8] c"history\00", align 1
@.str.50 = private unnamed_addr constant [85 x i8] c"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]\00", align 1
@.str.51 = private unnamed_addr constant [5 x i8] c"kill\00", align 1
@.str.52 = private unnamed_addr constant [80 x i8] c"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]\00", align 1
@.str.53 = private unnamed_addr constant [4 x i8] c"let\00", align 1
@.str.54 = private unnamed_addr constant [18 x i8] c"let arg [arg ...]\00", align 1
@.str.55 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.56 = private unnamed_addr constant [112 x i8] c"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]\00", align 1
@.str.57 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.58 = private unnamed_addr constant [11 x i8] c"return [n]\00", align 1
@.str.59 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str.60 = private unnamed_addr constant [57 x i8] c"set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]\00", align 1
@.str.61 = private unnamed_addr constant [6 x i8] c"unset\00", align 1
@.str.62 = private unnamed_addr constant [32 x i8] c"unset [-f] [-v] [-n] [name ...]\00", align 1
@.str.63 = private unnamed_addr constant [7 x i8] c"export\00", align 1
@.str.64 = private unnamed_addr constant [45 x i8] c"export [-fn] [name[=value] ...] or export -p\00", align 1
@.str.65 = private unnamed_addr constant [9 x i8] c"readonly\00", align 1
@.str.66 = private unnamed_addr constant [50 x i8] c"readonly [-aAf] [name[=value] ...] or readonly -p\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str.68 = private unnamed_addr constant [10 x i8] c"shift [n]\00", align 1
@.str.69 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@.str.70 = private unnamed_addr constant [28 x i8] c"source filename [arguments]\00", align 1
@.str.71 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.72 = private unnamed_addr constant [23 x i8] c". filename [arguments]\00", align 1
@.str.73 = private unnamed_addr constant [5 x i8] c"test\00", align 1
@.str.74 = private unnamed_addr constant [12 x i8] c"test [expr]\00", align 1
@.str.75 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.76 = private unnamed_addr constant [11 x i8] c"[ arg... ]\00", align 1
@.str.77 = private unnamed_addr constant [6 x i8] c"times\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"trap\00", align 1
@.str.79 = private unnamed_addr constant [35 x i8] c"trap [-lp] [[arg] signal_spec ...]\00", align 1
@.str.80 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.81 = private unnamed_addr constant [30 x i8] c"type [-afptP] name [name ...]\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"ulimit\00", align 1
@.str.83 = private unnamed_addr constant [42 x i8] c"ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]\00", align 1
@.str.84 = private unnamed_addr constant [6 x i8] c"umask\00", align 1
@.str.85 = private unnamed_addr constant [23 x i8] c"umask [-p] [-S] [mode]\00", align 1
@.str.86 = private unnamed_addr constant [5 x i8] c"wait\00", align 1
@.str.87 = private unnamed_addr constant [15 x i8] c"wait [pid ...]\00", align 1
@.str.88 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str.89 = private unnamed_addr constant [45 x i8] c"for NAME [in WORDS ... ] ; do COMMANDS; done\00", align 1
@.str.90 = private unnamed_addr constant [7 x i8] c"for ((\00", align 1
@.str.91 = private unnamed_addr constant [46 x i8] c"for (( exp1; exp2; exp3 )); do COMMANDS; done\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.93 = private unnamed_addr constant [47 x i8] c"select NAME [in WORDS ... ;] do COMMANDS; done\00", align 1
@.str.94 = private unnamed_addr constant [5 x i8] c"time\00", align 1
@.str.95 = private unnamed_addr constant [19 x i8] c"time [-p] pipeline\00", align 1
@.str.96 = private unnamed_addr constant [5 x i8] c"case\00", align 1
@.str.97 = private unnamed_addr constant [59 x i8] c"case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac\00", align 1
@.str.98 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.99 = private unnamed_addr constant [87 x i8] c"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi\00", align 1
@.str.100 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str.101 = private unnamed_addr constant [34 x i8] c"while COMMANDS; do COMMANDS; done\00", align 1
@.str.102 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str.103 = private unnamed_addr constant [34 x i8] c"until COMMANDS; do COMMANDS; done\00", align 1
@.str.104 = private unnamed_addr constant [7 x i8] c"coproc\00", align 1
@.str.105 = private unnamed_addr constant [37 x i8] c"coproc [NAME] command [redirections]\00", align 1
@.str.106 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.107 = private unnamed_addr constant [55 x i8] c"function name { COMMANDS ; } or name () { COMMANDS ; }\00", align 1
@.str.108 = private unnamed_addr constant [8 x i8] c"{ ... }\00", align 1
@.str.109 = private unnamed_addr constant [15 x i8] c"{ COMMANDS ; }\00", align 1
@.str.110 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.111 = private unnamed_addr constant [13 x i8] c"job_spec [&]\00", align 1
@.str.112 = private unnamed_addr constant [10 x i8] c"(( ... ))\00", align 1
@.str.113 = private unnamed_addr constant [17 x i8] c"(( expression ))\00", align 1
@.str.114 = private unnamed_addr constant [10 x i8] c"[[ ... ]]\00", align 1
@.str.115 = private unnamed_addr constant [17 x i8] c"[[ expression ]]\00", align 1
@.str.116 = private unnamed_addr constant [10 x i8] c"variables\00", align 1
@.str.117 = private unnamed_addr constant [55 x i8] c"variables - Names and meanings of some shell variables\00", align 1
@.str.118 = private unnamed_addr constant [6 x i8] c"pushd\00", align 1
@.str.119 = private unnamed_addr constant [27 x i8] c"pushd [-n] [+N | -N | dir]\00", align 1
@.str.120 = private unnamed_addr constant [5 x i8] c"popd\00", align 1
@.str.121 = private unnamed_addr constant [20 x i8] c"popd [-n] [+N | -N]\00", align 1
@.str.122 = private unnamed_addr constant [5 x i8] c"dirs\00", align 1
@.str.123 = private unnamed_addr constant [23 x i8] c"dirs [-clpv] [+N] [-N]\00", align 1
@.str.124 = private unnamed_addr constant [6 x i8] c"shopt\00", align 1
@.str.125 = private unnamed_addr constant [33 x i8] c"shopt [-pqsu] [-o] [optname ...]\00", align 1
@.str.126 = private unnamed_addr constant [7 x i8] c"printf\00", align 1
@.str.127 = private unnamed_addr constant [35 x i8] c"printf [-v var] format [arguments]\00", align 1
@.str.128 = private unnamed_addr constant [9 x i8] c"complete\00", align 1
@.str.129 = private unnamed_addr constant [166 x i8] c"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]\00", align 1
@.str.130 = private unnamed_addr constant [8 x i8] c"compgen\00", align 1
@.str.131 = private unnamed_addr constant [149 x i8] c"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]\00", align 1
@.str.132 = private unnamed_addr constant [8 x i8] c"compopt\00", align 1
@.str.133 = private unnamed_addr constant [40 x i8] c"compopt [-o|+o option] [-DE] [name ...]\00", align 1
@.str.134 = private unnamed_addr constant [8 x i8] c"mapfile\00", align 1
@.str.135 = private unnamed_addr constant [101 x i8] c"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]\00", align 1
@.str.136 = private unnamed_addr constant [10 x i8] c"readarray\00", align 1
@.str.137 = private unnamed_addr constant [92 x i8] c"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]\00", align 1
@static_shell_builtins = global [72 x %struct.builtin] [%struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 (%struct.word_list*)* @alias_builtin, i32 53, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @alias_doc, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.1, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 (%struct.word_list*)* @unalias_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @unalias_doc, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.3, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (%struct.word_list*)* @bind_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @bind_doc, i32 0, i32 0), i8* getelementptr inbounds ([148 x i8], [148 x i8]* @.str.5, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6, i32 0, i32 0), i32 (%struct.word_list*)* @break_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @break_doc, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (%struct.word_list*)* @continue_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @continue_doc, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.9, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.10, i32 0, i32 0), i32 (%struct.word_list*)* @builtin_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @builtin_doc, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.11, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i32 (%struct.word_list*)* @caller_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @caller_doc, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.13, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0), i32 (%struct.word_list*)* @cd_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @cd_doc, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.15, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 (%struct.word_list*)* @pwd_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @pwd_doc, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i32 0, i32 0), i32 (%struct.word_list*)* @colon_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @colon_doc, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i32 (%struct.word_list*)* @colon_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @true_doc, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.20, i32 0, i32 0), i32 (%struct.word_list*)* @false_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @false_doc, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.20, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21, i32 0, i32 0), i32 (%struct.word_list*)* @command_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @command_doc, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.22, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 (%struct.word_list*)* @declare_builtin, i32 85, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @declare_doc, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.24, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.25, i32 0, i32 0), i32 (%struct.word_list*)* @declare_builtin, i32 85, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @typeset_doc, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.26, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.27, i32 0, i32 0), i32 (%struct.word_list*)* @local_builtin, i32 85, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @local_doc, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.28, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i32 0, i32 0), i32 (%struct.word_list*)* @echo_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @echo_doc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.30, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i32 0, i32 0), i32 (%struct.word_list*)* @enable_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @enable_doc, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.32, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.33, i32 0, i32 0), i32 (%struct.word_list*)* @eval_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @eval_doc, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.34, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.35, i32 0, i32 0), i32 (%struct.word_list*)* @getopts_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @getopts_doc, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.36, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), i32 (%struct.word_list*)* @exec_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @exec_doc, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.38, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.39, i32 0, i32 0), i32 (%struct.word_list*)* @exit_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @exit_doc, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.40, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i32 (%struct.word_list*)* @logout_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @logout_doc, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.42, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i32 0, i32 0), i32 (%struct.word_list*)* @fc_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @fc_doc, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.44, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.45, i32 0, i32 0), i32 (%struct.word_list*)* @hash_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @hash_doc, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.46, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i32 (%struct.word_list*)* @help_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @help_doc, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.48, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i32 0, i32 0), i32 (%struct.word_list*)* @history_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @history_doc, i32 0, i32 0), i8* getelementptr inbounds ([85 x i8], [85 x i8]* @.str.50, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0), i32 (%struct.word_list*)* @kill_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @kill_doc, i32 0, i32 0), i8* getelementptr inbounds ([80 x i8], [80 x i8]* @.str.52, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.53, i32 0, i32 0), i32 (%struct.word_list*)* @let_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @let_doc, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.54, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.55, i32 0, i32 0), i32 (%struct.word_list*)* @read_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @read_doc, i32 0, i32 0), i8* getelementptr inbounds ([112 x i8], [112 x i8]* @.str.56, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.57, i32 0, i32 0), i32 (%struct.word_list*)* @return_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @return_doc, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.58, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.59, i32 0, i32 0), i32 (%struct.word_list*)* @set_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @set_doc, i32 0, i32 0), i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.60, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.61, i32 0, i32 0), i32 (%struct.word_list*)* @unset_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @unset_doc, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.62, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.63, i32 0, i32 0), i32 (%struct.word_list*)* @export_builtin, i32 29, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @export_doc, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.64, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.65, i32 0, i32 0), i32 (%struct.word_list*)* @readonly_builtin, i32 29, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @readonly_doc, i32 0, i32 0), i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.66, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i32 0, i32 0), i32 (%struct.word_list*)* @shift_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @shift_doc, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.68, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.69, i32 0, i32 0), i32 (%struct.word_list*)* @source_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @source_doc, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.70, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0), i32 (%struct.word_list*)* @source_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @dot_doc, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.72, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.73, i32 0, i32 0), i32 (%struct.word_list*)* @test_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @test_doc, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.74, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.75, i32 0, i32 0), i32 (%struct.word_list*)* @test_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @test_bracket_doc, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.76, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.77, i32 0, i32 0), i32 (%struct.word_list*)* @times_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @times_doc, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.77, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.78, i32 0, i32 0), i32 (%struct.word_list*)* @trap_builtin, i32 13, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @trap_doc, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.79, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.80, i32 0, i32 0), i32 (%struct.word_list*)* @type_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @type_doc, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.81, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i32 0, i32 0), i32 (%struct.word_list*)* @ulimit_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @ulimit_doc, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.83, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.84, i32 0, i32 0), i32 (%struct.word_list*)* @umask_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @umask_doc, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.85, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.86, i32 0, i32 0), i32 (%struct.word_list*)* @wait_builtin, i32 37, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @wait_doc, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.87, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.88, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @for_doc, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.89, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.90, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @arith_for_doc, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.91, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.92, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @select_doc, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.93, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.94, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @time_doc, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.95, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.96, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @case_doc, i32 0, i32 0), i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.97, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.98, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @if_doc, i32 0, i32 0), i8* getelementptr inbounds ([87 x i8], [87 x i8]* @.str.99, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.100, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @while_doc, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.101, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.102, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @until_doc, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.103, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.104, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @coproc_doc, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.105, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.106, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @function_doc, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.107, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.108, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @grouping_braces_doc, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.109, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @fg_percent_doc, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.111, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.112, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @arith_doc, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.113, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.114, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @conditional_doc, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.115, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.116, i32 0, i32 0), i32 (%struct.word_list*)* null, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @variable_help_doc, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.117, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.118, i32 0, i32 0), i32 (%struct.word_list*)* @pushd_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @pushd_doc, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.119, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.120, i32 0, i32 0), i32 (%struct.word_list*)* @popd_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @popd_doc, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.121, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.122, i32 0, i32 0), i32 (%struct.word_list*)* @dirs_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @dirs_doc, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.123, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.124, i32 0, i32 0), i32 (%struct.word_list*)* @shopt_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @shopt_doc, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.125, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.126, i32 0, i32 0), i32 (%struct.word_list*)* @printf_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @printf_doc, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.127, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.128, i32 0, i32 0), i32 (%struct.word_list*)* @complete_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @complete_doc, i32 0, i32 0), i8* getelementptr inbounds ([166 x i8], [166 x i8]* @.str.129, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.130, i32 0, i32 0), i32 (%struct.word_list*)* @compgen_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @compgen_doc, i32 0, i32 0), i8* getelementptr inbounds ([149 x i8], [149 x i8]* @.str.131, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.132, i32 0, i32 0), i32 (%struct.word_list*)* @compopt_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @compopt_doc, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.133, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.134, i32 0, i32 0), i32 (%struct.word_list*)* @mapfile_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @mapfile_doc, i32 0, i32 0), i8* getelementptr inbounds ([101 x i8], [101 x i8]* @.str.135, i32 0, i32 0), i8* null }, %struct.builtin { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.136, i32 0, i32 0), i32 (%struct.word_list*)* @mapfile_builtin, i32 5, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @readarray_doc, i32 0, i32 0), i8* getelementptr inbounds ([92 x i8], [92 x i8]* @.str.137, i32 0, i32 0), i8* null }, %struct.builtin zeroinitializer], align 4
@shell_builtins = global %struct.builtin* getelementptr inbounds ([72 x %struct.builtin], [72 x %struct.builtin]* @static_shell_builtins, i32 0, i32 0), align 4
@num_shell_builtins = global i32 71, align 4
@.str.138 = private unnamed_addr constant [536 x i8] c"Define or display aliases.\0A    \0A    Without arguments, `alias' prints the list of aliases in the reusable\0A    form `alias NAME=VALUE' on standard output.\0A    \0A    Otherwise, an alias is defined for each NAME whose VALUE is given.\0A    A trailing space in VALUE causes the next word to be checked for\0A    alias substitution when the alias is expanded.\0A    \0A    Options:\0A      -p\09print all defined aliases in a reusable format\0A    \0A    Exit Status:\0A    alias returns true unless a NAME is supplied for which no alias has been\0A    defined.\00", align 1
@alias_doc = constant [2 x i8*] [i8* getelementptr inbounds ([536 x i8], [536 x i8]* @.str.138, i32 0, i32 0), i8* null], align 4
@.str.140 = private unnamed_addr constant [171 x i8] c"Remove each NAME from the list of defined aliases.\0A    \0A    Options:\0A      -a\09remove all alias definitions\0A    \0A    Return success unless a NAME is not an existing alias.\00", align 1
@unalias_doc = constant [2 x i8*] [i8* getelementptr inbounds ([171 x i8], [171 x i8]* @.str.140, i32 0, i32 0), i8* null], align 4
@.str.142 = private unnamed_addr constant [1837 x i8] c"Set Readline key bindings and variables.\0A    \0A    Bind a key sequence to a Readline function or a macro, or set a\0A    Readline variable.  The non-option argument syntax is equivalent to\0A    that found in ~/.inputrc, but must be passed as a single argument:\0A    e.g., bind '\22\5CC-x\5CC-r\22: re-read-init-file'.\0A    \0A    Options:\0A      -m  keymap         Use KEYMAP as the keymap for the duration of this\0A                         command.  Acceptable keymap names are emacs,\0A                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\0A                         vi-command, and vi-insert.\0A      -l                 List names of functions.\0A      -P                 List function names and bindings.\0A      -p                 List functions and bindings in a form that can be\0A                         reused as input.\0A      -S                 List key sequences that invoke macros and their values\0A      -s                 List key sequences that invoke macros and their values\0A                         in a form that can be reused as input.\0A      -V                 List variable names and values\0A      -v                 List variable names and values in a form that can\0A                         be reused as input.\0A      -q  function-name  Query about which keys invoke the named function.\0A      -u  function-name  Unbind all keys which are bound to the named function.\0A      -r  keyseq         Remove the binding for KEYSEQ.\0A      -f  filename       Read key bindings from FILENAME.\0A      -x  keyseq:shell-command\09Cause SHELL-COMMAND to be executed when\0A    \09\09\09\09KEYSEQ is entered.\0A      -X                 List key sequences bound with -x and associated commands\0A                         in a form that can be reused as input.\0A    \0A    Exit Status:\0A    bind returns 0 unless an unrecognized option is given or an error occurs.\00", align 1
@bind_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1837 x i8], [1837 x i8]* @.str.142, i32 0, i32 0), i8* null], align 4
@.str.144 = private unnamed_addr constant [215 x i8] c"Exit for, while, or until loops.\0A    \0A    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\0A    loops.\0A    \0A    Exit Status:\0A    The exit status is 0 unless N is not greater than or equal to 1.\00", align 1
@break_doc = constant [2 x i8*] [i8* getelementptr inbounds ([215 x i8], [215 x i8]* @.str.144, i32 0, i32 0), i8* null], align 4
@.str.146 = private unnamed_addr constant [260 x i8] c"Resume for, while, or until loops.\0A    \0A    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\0A    If N is specified, resumes the Nth enclosing loop.\0A    \0A    Exit Status:\0A    The exit status is 0 unless N is not greater than or equal to 1.\00", align 1
@continue_doc = constant [2 x i8*] [i8* getelementptr inbounds ([260 x i8], [260 x i8]* @.str.146, i32 0, i32 0), i8* null], align 4
@.str.148 = private unnamed_addr constant [376 x i8] c"Execute shell builtins.\0A    \0A    Execute SHELL-BUILTIN with arguments ARGs without performing command\0A    lookup.  This is useful when you wish to reimplement a shell builtin\0A    as a shell function, but need to execute the builtin within the function.\0A    \0A    Exit Status:\0A    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\0A    not a shell builtin..\00", align 1
@builtin_doc = constant [2 x i8*] [i8* getelementptr inbounds ([376 x i8], [376 x i8]* @.str.148, i32 0, i32 0), i8* null], align 4
@.str.150 = private unnamed_addr constant [455 x i8] c"Return the context of the current subroutine call.\0A    \0A    Without EXPR, returns \22$line $filename\22.  With EXPR, returns\0A    \22$line $subroutine $filename\22; this extra information can be used to\0A    provide a stack trace.\0A    \0A    The value of EXPR indicates how many call frames to go back before the\0A    current one; the top frame is frame 0.\0A    \0A    Exit Status:\0A    Returns 0 unless the shell is not executing a shell function or EXPR\0A    is invalid.\00", align 1
@caller_doc = constant [2 x i8*] [i8* getelementptr inbounds ([455 x i8], [455 x i8]* @.str.150, i32 0, i32 0), i8* null], align 4
@.str.152 = private unnamed_addr constant [1531 x i8] c"Change the shell working directory.\0A    \0A    Change the current directory to DIR.  The default DIR is the value of the\0A    HOME shell variable.\0A    \0A    The variable CDPATH defines the search path for the directory containing\0A    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\0A    A null directory name is the same as the current directory.  If DIR begins\0A    with a slash (/), then CDPATH is not used.\0A    \0A    If the directory is not found, and the shell option `cdable_vars' is set,\0A    the word is assumed to be  a variable name.  If that variable has a value,\0A    its value is used for DIR.\0A    \0A    Options:\0A      -L\09force symbolic links to be followed: resolve symbolic\0A    \09\09links in DIR after processing instances of `..'\0A      -P\09use the physical directory structure without following\0A    \09\09symbolic links: resolve symbolic links in DIR before\0A    \09\09processing instances of `..'\0A      -e\09if the -P option is supplied, and the current working\0A    \09\09directory cannot be determined successfully, exit with\0A    \09\09a non-zero status\0A      -@\09on systems that support it, present a file with extended\0A    \09\09attributes as a directory containing the file attributes\0A    \0A    The default is to follow symbolic links, as if `-L' were specified.\0A    `..' is processed by removing the immediately previous pathname component\0A    back to a slash or the beginning of DIR.\0A    \0A    Exit Status:\0A    Returns 0 if the directory is changed, and if $PWD is set successfully when\0A    -P is used; non-zero otherwise.\00", align 1
@cd_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1531 x i8], [1531 x i8]* @.str.152, i32 0, i32 0), i8* null], align 4
@.str.154 = private unnamed_addr constant [391 x i8] c"Print the name of the current working directory.\0A    \0A    Options:\0A      -L\09print the value of $PWD if it names the current working\0A    \09\09directory\0A      -P\09print the physical directory, without any symbolic links\0A    \0A    By default, `pwd' behaves as if `-L' were specified.\0A    \0A    Exit Status:\0A    Returns 0 unless an invalid option is given or the current directory\0A    cannot be read.\00", align 1
@pwd_doc = constant [2 x i8*] [i8* getelementptr inbounds ([391 x i8], [391 x i8]* @.str.154, i32 0, i32 0), i8* null], align 4
@.str.156 = private unnamed_addr constant [103 x i8] c"Null command.\0A    \0A    No effect; the command does nothing.\0A    \0A    Exit Status:\0A    Always succeeds.\00", align 1
@colon_doc = constant [2 x i8*] [i8* getelementptr inbounds ([103 x i8], [103 x i8]* @.str.156, i32 0, i32 0), i8* null], align 4
@.str.158 = private unnamed_addr constant [71 x i8] c"Return a successful result.\0A    \0A    Exit Status:\0A    Always succeeds.\00", align 1
@true_doc = constant [2 x i8*] [i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.158, i32 0, i32 0), i8* null], align 4
@.str.160 = private unnamed_addr constant [71 x i8] c"Return an unsuccessful result.\0A    \0A    Exit Status:\0A    Always fails.\00", align 1
@false_doc = constant [2 x i8*] [i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.160, i32 0, i32 0), i8* null], align 4
@.str.162 = private unnamed_addr constant [632 x i8] c"Execute a simple command or display information about commands.\0A    \0A    Runs COMMAND with ARGS suppressing  shell function lookup, or display\0A    information about the specified COMMANDs.  Can be used to invoke commands\0A    on disk when a function with the same name exists.\0A    \0A    Options:\0A      -p    use a default value for PATH that is guaranteed to find all of\0A            the standard utilities\0A      -v    print a description of COMMAND similar to the `type' builtin\0A      -V    print a more verbose description of each COMMAND\0A    \0A    Exit Status:\0A    Returns exit status of COMMAND, or failure if COMMAND is not found.\00", align 1
@command_doc = constant [2 x i8*] [i8* getelementptr inbounds ([632 x i8], [632 x i8]* @.str.162, i32 0, i32 0), i8* null], align 4
@.str.164 = private unnamed_addr constant [1468 x i8] c"Set variable values and attributes.\0A    \0A    Declare variables and give them attributes.  If no NAMEs are given,\0A    display the attributes and values of all variables.\0A    \0A    Options:\0A      -f\09restrict action or display to function names and definitions\0A      -F\09restrict display to function names only (plus line number and\0A    \09\09source file when debugging)\0A      -g\09create global variables when used in a shell function; otherwise\0A    \09\09ignored\0A      -p\09display the attributes and value of each NAME\0A    \0A    Options which set attributes:\0A      -a\09to make NAMEs indexed arrays (if supported)\0A      -A\09to make NAMEs associative arrays (if supported)\0A      -i\09to make NAMEs have the `integer' attribute\0A      -l\09to convert NAMEs to lower case on assignment\0A      -n\09make NAME a reference to the variable named by its value\0A      -r\09to make NAMEs readonly\0A      -t\09to make NAMEs have the `trace' attribute\0A      -u\09to convert NAMEs to upper case on assignment\0A      -x\09to make NAMEs export\0A    \0A    Using `+' instead of `-' turns off the given attribute.\0A    \0A    Variables with the integer attribute have arithmetic evaluation (see\0A    the `let' command) performed when the variable is assigned a value.\0A    \0A    When used in a function, `declare' makes NAMEs local, as with the `local'\0A    command.  The `-g' option suppresses this behavior.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied or a variable\0A    assignment error occurs.\00", align 1
@declare_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1468 x i8], [1468 x i8]* @.str.164, i32 0, i32 0), i8* null], align 4
@.str.166 = private unnamed_addr constant [91 x i8] c"Set variable values and attributes.\0A    \0A    A synonym for `declare'.  See `help declare'.\00", align 1
@typeset_doc = constant [2 x i8*] [i8* getelementptr inbounds ([91 x i8], [91 x i8]* @.str.166, i32 0, i32 0), i8* null], align 4
@.str.168 = private unnamed_addr constant [448 x i8] c"Define local variables.\0A    \0A    Create a local variable called NAME, and give it VALUE.  OPTION can\0A    be any option accepted by `declare'.\0A    \0A    Local variables can only be used within a function; they are visible\0A    only to the function where they are defined and its children.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied, a variable\0A    assignment error occurs, or the shell is not executing a function.\00", align 1
@local_doc = constant [2 x i8*] [i8* getelementptr inbounds ([448 x i8], [448 x i8]* @.str.168, i32 0, i32 0), i8* null], align 4
@.str.170 = private unnamed_addr constant [941 x i8] c"Write arguments to the standard output.\0A    \0A    Display the ARGs, separated by a single space character and followed by a\0A    newline, on the standard output.\0A    \0A    Options:\0A      -n\09do not append a newline\0A      -e\09enable interpretation of the following backslash escapes\0A      -E\09explicitly suppress interpretation of backslash escapes\0A    \0A    `echo' interprets the following backslash-escaped characters:\0A      \5Ca\09alert (bell)\0A      \5Cb\09backspace\0A      \5Cc\09suppress further output\0A      \5Ce\09escape character\0A      \5CE\09escape character\0A      \5Cf\09form feed\0A      \5Cn\09new line\0A      \5Cr\09carriage return\0A      \5Ct\09horizontal tab\0A      \5Cv\09vertical tab\0A      \5C\5C\09backslash\0A      \5C0nnn\09the character whose ASCII code is NNN (octal).  NNN can be\0A    \09\090 to 3 octal digits\0A      \5CxHH\09the eight-bit character whose value is HH (hexadecimal).  HH\0A    \09\09can be one or two hex digits\0A    \0A    Exit Status:\0A    Returns success unless a write error occurs.\00", align 1
@echo_doc = constant [2 x i8*] [i8* getelementptr inbounds ([941 x i8], [941 x i8]* @.str.170, i32 0, i32 0), i8* null], align 4
@.str.172 = private unnamed_addr constant [885 x i8] c"Enable and disable shell builtins.\0A    \0A    Enables and disables builtin shell commands.  Disabling allows you to\0A    execute a disk command which has the same name as a shell builtin\0A    without using a full pathname.\0A    \0A    Options:\0A      -a\09print a list of builtins showing whether or not each is enabled\0A      -n\09disable each NAME or display a list of disabled builtins\0A      -p\09print the list of builtins in a reusable format\0A      -s\09print only the names of Posix `special' builtins\0A    \0A    Options controlling dynamic loading:\0A      -f\09Load builtin NAME from shared object FILENAME\0A      -d\09Remove a builtin loaded with -f\0A    \0A    Without options, each NAME is enabled.\0A    \0A    To use the `test' found in $PATH instead of the shell builtin\0A    version, type `enable -n test'.\0A    \0A    Exit Status:\0A    Returns success unless NAME is not a shell builtin or an error occurs.\00", align 1
@enable_doc = constant [2 x i8*] [i8* getelementptr inbounds ([885 x i8], [885 x i8]* @.str.172, i32 0, i32 0), i8* null], align 4
@.str.174 = private unnamed_addr constant [248 x i8] c"Execute arguments as a shell command.\0A    \0A    Combine ARGs into a single string, use the result as input to the shell,\0A    and execute the resulting commands.\0A    \0A    Exit Status:\0A    Returns exit status of command or success if command is null.\00", align 1
@eval_doc = constant [2 x i8*] [i8* getelementptr inbounds ([248 x i8], [248 x i8]* @.str.174, i32 0, i32 0), i8* null], align 4
@.str.176 = private unnamed_addr constant [1859 x i8] c"Parse option arguments.\0A    \0A    Getopts is used by shell procedures to parse positional parameters\0A    as options.\0A    \0A    OPTSTRING contains the option letters to be recognized; if a letter\0A    is followed by a colon, the option is expected to have an argument,\0A    which should be separated from it by white space.\0A    \0A    Each time it is invoked, getopts will place the next option in the\0A    shell variable $name, initializing name if it does not exist, and\0A    the index of the next argument to be processed into the shell\0A    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\0A    a shell script is invoked.  When an option requires an argument,\0A    getopts places that argument into the shell variable OPTARG.\0A    \0A    getopts reports errors in one of two ways.  If the first character\0A    of OPTSTRING is a colon, getopts uses silent error reporting.  In\0A    this mode, no error messages are printed.  If an invalid option is\0A    seen, getopts places the option character found into OPTARG.  If a\0A    required argument is not found, getopts places a ':' into NAME and\0A    sets OPTARG to the option character found.  If getopts is not in\0A    silent mode, and an invalid option is seen, getopts places '?' into\0A    NAME and unsets OPTARG.  If a required argument is not found, a '?'\0A    is placed in NAME, OPTARG is unset, and a diagnostic message is\0A    printed.\0A    \0A    If the shell variable OPTERR has the value 0, getopts disables the\0A    printing of error messages, even if the first character of\0A    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\0A    \0A    Getopts normally parses the positional parameters ($0 - $9), but if\0A    more arguments are given, they are parsed instead.\0A    \0A    Exit Status:\0A    Returns success if an option is found; fails if the end of options is\0A    encountered or an error occurs.\00", align 1
@getopts_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1859 x i8], [1859 x i8]* @.str.176, i32 0, i32 0), i8* null], align 4
@.str.178 = private unnamed_addr constant [655 x i8] c"Replace the shell with the given command.\0A    \0A    Execute COMMAND, replacing this shell with the specified program.\0A    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\0A    any redirections take effect in the current shell.\0A    \0A    Options:\0A      -a name\09pass NAME as the zeroth argument to COMMAND\0A      -c\09execute COMMAND with an empty environment\0A      -l\09place a dash in the zeroth argument to COMMAND\0A    \0A    If the command cannot be executed, a non-interactive shell exits, unless\0A    the shell option `execfail' is set.\0A    \0A    Exit Status:\0A    Returns success unless COMMAND is not found or a redirection error occurs.\00", align 1
@exec_doc = constant [2 x i8*] [i8* getelementptr inbounds ([655 x i8], [655 x i8]* @.str.178, i32 0, i32 0), i8* null], align 4
@.str.180 = private unnamed_addr constant [137 x i8] c"Exit the shell.\0A    \0A    Exits the shell with a status of N.  If N is omitted, the exit status\0A    is that of the last command executed.\00", align 1
@exit_doc = constant [2 x i8*] [i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.str.180, i32 0, i32 0), i8* null], align 4
@.str.182 = private unnamed_addr constant [125 x i8] c"Exit a login shell.\0A    \0A    Exits a login shell with exit status N.  Returns an error if not executed\0A    in a login shell.\00", align 1
@logout_doc = constant [2 x i8*] [i8* getelementptr inbounds ([125 x i8], [125 x i8]* @.str.182, i32 0, i32 0), i8* null], align 4
@.str.184 = private unnamed_addr constant [942 x i8] c"Display or execute commands from the history list.\0A    \0A    fc is used to list or edit and re-execute commands from the history list.\0A    FIRST and LAST can be numbers specifying the range, or FIRST can be a\0A    string, which means the most recent command beginning with that\0A    string.\0A    \0A    Options:\0A      -e ENAME\09select which editor to use.  Default is FCEDIT, then EDITOR,\0A    \09\09then vi\0A      -l \09list lines instead of editing\0A      -n\09omit line numbers when listing\0A      -r\09reverse the order of the lines (newest listed first)\0A    \0A    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\0A    re-executed after the substitution OLD=NEW is performed.\0A    \0A    A useful alias to use with this is r='fc -s', so that typing `r cc'\0A    runs the last command beginning with `cc' and typing `r' re-executes\0A    the last command.\0A    \0A    Exit Status:\0A    Returns success or status of executed command; non-zero if an error occurs.\00", align 1
@fc_doc = constant [2 x i8*] [i8* getelementptr inbounds ([942 x i8], [942 x i8]* @.str.184, i32 0, i32 0), i8* null], align 4
@.str.186 = private unnamed_addr constant [780 x i8] c"Remember or display program locations.\0A    \0A    Determine and remember the full pathname of each command NAME.  If\0A    no arguments are given, information about remembered commands is displayed.\0A    \0A    Options:\0A      -d\09forget the remembered location of each NAME\0A      -l\09display in a format that may be reused as input\0A      -p pathname\09use PATHNAME as the full pathname of NAME\0A      -r\09forget all remembered locations\0A      -t\09print the remembered location of each NAME, preceding\0A    \09\09each location with the corresponding NAME if multiple\0A    \09\09NAMEs are given\0A    Arguments:\0A      NAME\09Each NAME is searched for in $PATH and added to the list\0A    \09\09of remembered commands.\0A    \0A    Exit Status:\0A    Returns success unless NAME is not found or an invalid option is given.\00", align 1
@hash_doc = constant [2 x i8*] [i8* getelementptr inbounds ([780 x i8], [780 x i8]* @.str.186, i32 0, i32 0), i8* null], align 4
@.str.188 = private unnamed_addr constant [598 x i8] c"Display information about builtin commands.\0A    \0A    Displays brief summaries of builtin commands.  If PATTERN is\0A    specified, gives detailed help on all commands matching PATTERN,\0A    otherwise the list of help topics is printed.\0A    \0A    Options:\0A      -d\09output short description for each topic\0A      -m\09display usage in pseudo-manpage format\0A      -s\09output only a short usage synopsis for each topic matching\0A    \09\09PATTERN\0A    \0A    Arguments:\0A      PATTERN\09Pattern specifiying a help topic\0A    \0A    Exit Status:\0A    Returns success unless PATTERN is not found or an invalid option is given.\00", align 1
@help_doc = constant [2 x i8*] [i8* getelementptr inbounds ([598 x i8], [598 x i8]* @.str.188, i32 0, i32 0), i8* null], align 4
@.str.190 = private unnamed_addr constant [1302 x i8] c"Display or manipulate the history list.\0A    \0A    Display the history list with line numbers, prefixing each modified\0A    entry with a `*'.  An argument of N lists only the last N entries.\0A    \0A    Options:\0A      -c\09clear the history list by deleting all of the entries\0A      -d offset\09delete the history entry at position OFFSET.\0A    \0A      -a\09append history lines from this session to the history file\0A      -n\09read all history lines not already read from the history file\0A    \09\09and append them to the history list\0A      -r\09read the history file and append the contents to the history\0A    \09\09list\0A      -w\09write the current history to the history file\0A    \0A      -p\09perform history expansion on each ARG and display the result\0A    \09\09without storing it in the history list\0A      -s\09append the ARGs to the history list as a single entry\0A    \0A    If FILENAME is given, it is used as the history file.  Otherwise,\0A    if HISTFILE has a value, that is used, else ~/.bash_history.\0A    \0A    If the HISTTIMEFORMAT variable is set and not null, its value is used\0A    as a format string for strftime(3) to print the time stamp associated\0A    with each displayed history entry.  No time stamps are printed otherwise.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or an error occurs.\00", align 1
@history_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1302 x i8], [1302 x i8]* @.str.190, i32 0, i32 0), i8* null], align 4
@.str.192 = private unnamed_addr constant [741 x i8] c"Send a signal to a job.\0A    \0A    Send the processes identified by PID or JOBSPEC the signal named by\0A    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\0A    SIGTERM is assumed.\0A    \0A    Options:\0A      -s sig\09SIG is a signal name\0A      -n sig\09SIG is a signal number\0A      -l\09list the signal names; if arguments follow `-l' they are\0A    \09\09assumed to be signal numbers for which names should be listed\0A      -L\09synonym for -l\0A    \0A    Kill is a shell builtin for two reasons: it allows job IDs to be used\0A    instead of process IDs, and allows processes to be killed if the limit\0A    on processes that you can create is reached.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or an error occurs.\00", align 1
@kill_doc = constant [2 x i8*] [i8* getelementptr inbounds ([741 x i8], [741 x i8]* @.str.192, i32 0, i32 0), i8* null], align 4
@.str.194 = private unnamed_addr constant [1517 x i8] c"Evaluate arithmetic expressions.\0A    \0A    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\0A    fixed-width integers with no check for overflow, though division by 0\0A    is trapped and flagged as an error.  The following list of operators is\0A    grouped into levels of equal-precedence operators.  The levels are listed\0A    in order of decreasing precedence.\0A    \0A    \09id++, id--\09variable post-increment, post-decrement\0A    \09++id, --id\09variable pre-increment, pre-decrement\0A    \09-, +\09\09unary minus, plus\0A    \09!, ~\09\09logical and bitwise negation\0A    \09**\09\09exponentiation\0A    \09*, /, %\09\09multiplication, division, remainder\0A    \09+, -\09\09addition, subtraction\0A    \09<<, >>\09\09left and right bitwise shifts\0A    \09<=, >=, <, >\09comparison\0A    \09==, !=\09\09equality, inequality\0A    \09&\09\09bitwise AND\0A    \09^\09\09bitwise XOR\0A    \09|\09\09bitwise OR\0A    \09&&\09\09logical AND\0A    \09||\09\09logical OR\0A    \09expr ? expr : expr\0A    \09\09\09conditional operator\0A    \09=, *=, /=, %=,\0A    \09+=, -=, <<=, >>=,\0A    \09&=, ^=, |=\09assignment\0A    \0A    Shell variables are allowed as operands.  The name of the variable\0A    is replaced by its value (coerced to a fixed-width integer) within\0A    an expression.  The variable need not have its integer attribute\0A    turned on to be used in an expression.\0A    \0A    Operators are evaluated in order of precedence.  Sub-expressions in\0A    parentheses are evaluated first and may override the precedence\0A    rules above.\0A    \0A    Exit Status:\0A    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.\00", align 1
@let_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1517 x i8], [1517 x i8]* @.str.194, i32 0, i32 0), i8* null], align 4
@.str.196 = private unnamed_addr constant [2221 x i8] c"Read a line from the standard input and split it into fields.\0A    \0A    Reads a single line from the standard input, or from file descriptor FD\0A    if the -u option is supplied.  The line is split into fields as with word\0A    splitting, and the first word is assigned to the first NAME, the second\0A    word to the second NAME, and so on, with any leftover words assigned to\0A    the last NAME.  Only the characters found in $IFS are recognized as word\0A    delimiters.\0A    \0A    If no NAMEs are supplied, the line read is stored in the REPLY variable.\0A    \0A    Options:\0A      -a array\09assign the words read to sequential indices of the array\0A    \09\09variable ARRAY, starting at zero\0A      -d delim\09continue until the first character of DELIM is read, rather\0A    \09\09than newline\0A      -e\09use Readline to obtain the line in an interactive shell\0A      -i text\09use TEXT as the initial text for Readline\0A      -n nchars\09return after reading NCHARS characters rather than waiting\0A    \09\09for a newline, but honor a delimiter if fewer than\0A    \09\09NCHARS characters are read before the delimiter\0A      -N nchars\09return only after reading exactly NCHARS characters, unless\0A    \09\09EOF is encountered or read times out, ignoring any\0A    \09\09delimiter\0A      -p prompt\09output the string PROMPT without a trailing newline before\0A    \09\09attempting to read\0A      -r\09do not allow backslashes to escape any characters\0A      -s\09do not echo input coming from a terminal\0A      -t timeout\09time out and return failure if a complete line of\0A    \09\09input is not read within TIMEOUT seconds.  The value of the\0A    \09\09TMOUT variable is the default timeout.  TIMEOUT may be a\0A    \09\09fractional number.  If TIMEOUT is 0, read returns\0A    \09\09immediately, without trying to read any data, returning\0A    \09\09success only if input is available on the specified\0A    \09\09file descriptor.  The exit status is greater than 128\0A    \09\09if the timeout is exceeded\0A      -u fd\09read from file descriptor FD instead of the standard input\0A    \0A    Exit Status:\0A    The return code is zero, unless end-of-file is encountered, read times out\0A    (in which case it's greater than 128), a variable assignment error occurs,\0A    or an invalid file descriptor is supplied as the argument to -u.\00", align 1
@read_doc = constant [2 x i8*] [i8* getelementptr inbounds ([2221 x i8], [2221 x i8]* @.str.196, i32 0, i32 0), i8* null], align 4
@.str.198 = private unnamed_addr constant [333 x i8] c"Return from a shell function.\0A    \0A    Causes a function or sourced script to exit with the return value\0A    specified by N.  If N is omitted, the return status is that of the\0A    last command executed within the function or script.\0A    \0A    Exit Status:\0A    Returns N, or failure if the shell is not executing a function or script.\00", align 1
@return_doc = constant [2 x i8*] [i8* getelementptr inbounds ([333 x i8], [333 x i8]* @.str.198, i32 0, i32 0), i8* null], align 4
@.str.200 = private unnamed_addr constant [4123 x i8] c"Set or unset values of shell options and positional parameters.\0A    \0A    Change the value of shell attributes and positional parameters, or\0A    display the names and values of shell variables.\0A    \0A    Options:\0A      -a  Mark variables which are modified or created for export.\0A      -b  Notify of job termination immediately.\0A      -e  Exit immediately if a command exits with a non-zero status.\0A      -f  Disable file name generation (globbing).\0A      -h  Remember the location of commands as they are looked up.\0A      -k  All assignment arguments are placed in the environment for a\0A          command, not just those that precede the command name.\0A      -m  Job control is enabled.\0A      -n  Read commands but do not execute them.\0A      -o option-name\0A          Set the variable corresponding to option-name:\0A              allexport    same as -a\0A              braceexpand  same as -B\0A              emacs        use an emacs-style line editing interface\0A              errexit      same as -e\0A              errtrace     same as -E\0A              functrace    same as -T\0A              hashall      same as -h\0A              histexpand   same as -H\0A              history      enable command history\0A              ignoreeof    the shell will not exit upon reading EOF\0A              interactive-comments\0A                           allow comments to appear in interactive commands\0A              keyword      same as -k\0A              monitor      same as -m\0A              noclobber    same as -C\0A              noexec       same as -n\0A              noglob       same as -f\0A              nolog        currently accepted but ignored\0A              notify       same as -b\0A              nounset      same as -u\0A              onecmd       same as -t\0A              physical     same as -P\0A              pipefail     the return value of a pipeline is the status of\0A                           the last command to exit with a non-zero status,\0A                           or zero if no command exited with a non-zero status\0A              posix        change the behavior of bash where the default\0A                           operation differs from the Posix standard to\0A                           match the standard\0A              privileged   same as -p\0A              verbose      same as -v\0A              vi           use a vi-style line editing interface\0A              xtrace       same as -x\0A      -p  Turned on whenever the real and effective user ids do not match.\0A          Disables processing of the $ENV file and importing of shell\0A          functions.  Turning this option off causes the effective uid and\0A          gid to be set to the real uid and gid.\0A      -t  Exit after reading and executing one command.\0A      -u  Treat unset variables as an error when substituting.\0A      -v  Print shell input lines as they are read.\0A      -x  Print commands and their arguments as they are executed.\0A      -B  the shell will perform brace expansion\0A      -C  If set, disallow existing regular files to be overwritten\0A          by redirection of output.\0A      -E  If set, the ERR trap is inherited by shell functions.\0A      -H  Enable ! style history substitution.  This flag is on\0A          by default when the shell is interactive.\0A      -P  If set, do not resolve symbolic links when executing commands\0A          such as cd which change the current directory.\0A      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\0A      --  Assign any remaining arguments to the positional parameters.\0A          If there are no remaining arguments, the positional parameters\0A          are unset.\0A      -   Assign any remaining arguments to the positional parameters.\0A          The -x and -v options are turned off.\0A    \0A    Using + rather than - causes these flags to be turned off.  The\0A    flags can also be used upon invocation of the shell.  The current\0A    set of flags may be found in $-.  The remaining n ARGs are positional\0A    parameters and are assigned, in order, to $1, $2, .. $n.  If no\0A    ARGs are given, all shell variables are printed.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given.\00", align 1
@set_doc = constant [2 x i8*] [i8* getelementptr inbounds ([4123 x i8], [4123 x i8]* @.str.200, i32 0, i32 0), i8* null], align 4
@.str.202 = private unnamed_addr constant [638 x i8] c"Unset values and attributes of shell variables and functions.\0A    \0A    For each NAME, remove the corresponding variable or function.\0A    \0A    Options:\0A      -f\09treat each NAME as a shell function\0A      -v\09treat each NAME as a shell variable\0A      -n\09treat each NAME as a name reference and unset the variable itself\0A    \09\09rather than the variable it references\0A    \0A    Without options, unset first tries to unset a variable, and if that fails,\0A    tries to unset a function.\0A    \0A    Some variables cannot be unset; also see `readonly'.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or a NAME is read-only.\00", align 1
@unset_doc = constant [2 x i8*] [i8* getelementptr inbounds ([638 x i8], [638 x i8]* @.str.202, i32 0, i32 0), i8* null], align 4
@.str.204 = private unnamed_addr constant [528 x i8] c"Set export attribute for shell variables.\0A    \0A    Marks each NAME for automatic export to the environment of subsequently\0A    executed commands.  If VALUE is supplied, assign VALUE before exporting.\0A    \0A    Options:\0A      -f\09refer to shell functions\0A      -n\09remove the export property from each NAME\0A      -p\09display a list of all exported variables and functions\0A    \0A    An argument of `--' disables further option processing.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or NAME is invalid.\00", align 1
@export_doc = constant [2 x i8*] [i8* getelementptr inbounds ([528 x i8], [528 x i8]* @.str.204, i32 0, i32 0), i8* null], align 4
@.str.206 = private unnamed_addr constant [642 x i8] c"Mark shell variables as unchangeable.\0A    \0A    Mark each NAME as read-only; the values of these NAMEs may not be\0A    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\0A    before marking as read-only.\0A    \0A    Options:\0A      -a\09refer to indexed array variables\0A      -A\09refer to associative array variables\0A      -f\09refer to shell functions\0A      -p\09display a list of all readonly variables or functions,\0A    \09\09depending on whether or not the -f option is given\0A    \0A    An argument of `--' disables further option processing.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or NAME is invalid.\00", align 1
@readonly_doc = constant [2 x i8*] [i8* getelementptr inbounds ([642 x i8], [642 x i8]* @.str.206, i32 0, i32 0), i8* null], align 4
@.str.208 = private unnamed_addr constant [228 x i8] c"Shift positional parameters.\0A    \0A    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\0A    not given, it is assumed to be 1.\0A    \0A    Exit Status:\0A    Returns success unless N is negative or greater than $#.\00", align 1
@shift_doc = constant [2 x i8*] [i8* getelementptr inbounds ([228 x i8], [228 x i8]* @.str.208, i32 0, i32 0), i8* null], align 4
@.str.210 = private unnamed_addr constant [429 x i8] c"Execute commands from a file in the current shell.\0A    \0A    Read and execute commands from FILENAME in the current shell.  The\0A    entries in $PATH are used to find the directory containing FILENAME.\0A    If any ARGUMENTS are supplied, they become the positional parameters\0A    when FILENAME is executed.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed in FILENAME; fails if\0A    FILENAME cannot be read.\00", align 1
@source_doc = constant [2 x i8*] [i8* getelementptr inbounds ([429 x i8], [429 x i8]* @.str.210, i32 0, i32 0), i8* null], align 4
@dot_doc = constant [2 x i8*] [i8* getelementptr inbounds ([429 x i8], [429 x i8]* @.str.210, i32 0, i32 0), i8* null], align 4
@.str.213 = private unnamed_addr constant [3259 x i8] c"Evaluate conditional expression.\0A    \0A    Exits with a status of 0 (true) or 1 (false) depending on\0A    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\0A    expressions are often used to examine the status of a file.  There\0A    are string operators and numeric comparison operators as well.\0A    \0A    The behavior of test depends on the number of arguments.  Read the\0A    bash manual page for the complete specification.\0A    \0A    File operators:\0A    \0A      -a FILE        True if file exists.\0A      -b FILE        True if file is block special.\0A      -c FILE        True if file is character special.\0A      -d FILE        True if file is a directory.\0A      -e FILE        True if file exists.\0A      -f FILE        True if file exists and is a regular file.\0A      -g FILE        True if file is set-group-id.\0A      -h FILE        True if file is a symbolic link.\0A      -L FILE        True if file is a symbolic link.\0A      -k FILE        True if file has its `sticky' bit set.\0A      -p FILE        True if file is a named pipe.\0A      -r FILE        True if file is readable by you.\0A      -s FILE        True if file exists and is not empty.\0A      -S FILE        True if file is a socket.\0A      -t FD          True if FD is opened on a terminal.\0A      -u FILE        True if the file is set-user-id.\0A      -w FILE        True if the file is writable by you.\0A      -x FILE        True if the file is executable by you.\0A      -O FILE        True if the file is effectively owned by you.\0A      -G FILE        True if the file is effectively owned by your group.\0A      -N FILE        True if the file has been modified since it was last read.\0A    \0A      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\0A                       modification date).\0A    \0A      FILE1 -ot FILE2  True if file1 is older than file2.\0A    \0A      FILE1 -ef FILE2  True if file1 is a hard link to file2.\0A    \0A    String operators:\0A    \0A      -z STRING      True if string is empty.\0A    \0A      -n STRING\0A         STRING      True if string is not empty.\0A    \0A      STRING1 = STRING2\0A                     True if the strings are equal.\0A      STRING1 != STRING2\0A                     True if the strings are not equal.\0A      STRING1 < STRING2\0A                     True if STRING1 sorts before STRING2 lexicographically.\0A      STRING1 > STRING2\0A                     True if STRING1 sorts after STRING2 lexicographically.\0A    \0A    Other operators:\0A    \0A      -o OPTION      True if the shell option OPTION is enabled.\0A      -v VAR         True if the shell variable VAR is set.\0A      -R VAR         True if the shell variable VAR is set and is a name\0A                     reference.\0A      ! EXPR         True if expr is false.\0A      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\0A      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\0A    \0A      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\0A                     -lt, -le, -gt, or -ge.\0A    \0A    Arithmetic binary operators return true if ARG1 is equal, not-equal,\0A    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\0A    than ARG2.\0A    \0A    Exit Status:\0A    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\0A    false or an invalid argument is given.\00", align 1
@test_doc = constant [2 x i8*] [i8* getelementptr inbounds ([3259 x i8], [3259 x i8]* @.str.213, i32 0, i32 0), i8* null], align 4
@.str.215 = private unnamed_addr constant [159 x i8] c"Evaluate conditional expression.\0A    \0A    This is a synonym for the \22test\22 builtin, but the last argument must\0A    be a literal `]', to match the opening `['.\00", align 1
@test_bracket_doc = constant [2 x i8*] [i8* getelementptr inbounds ([159 x i8], [159 x i8]* @.str.215, i32 0, i32 0), i8* null], align 4
@.str.217 = private unnamed_addr constant [170 x i8] c"Display process times.\0A    \0A    Prints the accumulated user and system times for the shell and all of its\0A    child processes.\0A    \0A    Exit Status:\0A    Always succeeds.\00", align 1
@times_doc = constant [2 x i8*] [i8* getelementptr inbounds ([170 x i8], [170 x i8]* @.str.217, i32 0, i32 0), i8* null], align 4
@.str.219 = private unnamed_addr constant [1494 x i8] c"Trap signals and other events.\0A    \0A    Defines and activates handlers to be run when the shell receives signals\0A    or other conditions.\0A    \0A    ARG is a command to be read and executed when the shell receives the\0A    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\0A    is supplied) or `-', each specified signal is reset to its original\0A    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\0A    shell and by the commands it invokes.\0A    \0A    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\0A    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\0A    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\0A    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\0A    of ERR means to execute ARG each time a command's failure would cause the\0A    shell to exit when the -e option is enabled.\0A    \0A    If no arguments are supplied, trap prints the list of commands associated\0A    with each signal.\0A    \0A    Options:\0A      -l\09print a list of signal names and their corresponding numbers\0A      -p\09display the trap commands associated with each SIGNAL_SPEC\0A    \0A    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\0A    Signal names are case insensitive and the SIG prefix is optional.  A\0A    signal may be sent to the shell with \22kill -signal $$\22.\0A    \0A    Exit Status:\0A    Returns success unless a SIGSPEC is invalid or an invalid option is given.\00", align 1
@trap_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1494 x i8], [1494 x i8]* @.str.219, i32 0, i32 0), i8* null], align 4
@.str.221 = private unnamed_addr constant [1053 x i8] c"Display information about command type.\0A    \0A    For each NAME, indicate how it would be interpreted if used as a\0A    command name.\0A    \0A    Options:\0A      -a\09display all locations containing an executable named NAME;\0A    \09\09includes aliases, builtins, and functions, if and only if\0A    \09\09the `-p' option is not also used\0A      -f\09suppress shell function lookup\0A      -P\09force a PATH search for each NAME, even if it is an alias,\0A    \09\09builtin, or function, and returns the name of the disk file\0A    \09\09that would be executed\0A      -p\09returns either the name of the disk file that would be executed,\0A    \09\09or nothing if `type -t NAME' would not return `file'\0A      -t\09output a single word which is one of `alias', `keyword',\0A    \09\09`function', `builtin', `file' or `', if NAME is an alias,\0A    \09\09shell reserved word, shell function, shell builtin, disk file,\0A    \09\09or not found, respectively\0A    \0A    Arguments:\0A      NAME\09Command name to be interpreted.\0A    \0A    Exit Status:\0A    Returns success if all of the NAMEs are found; fails if any are not found.\00", align 1
@type_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1053 x i8], [1053 x i8]* @.str.221, i32 0, i32 0), i8* null], align 4
@.str.223 = private unnamed_addr constant [1936 x i8] c"Modify shell resource limits.\0A    \0A    Provides control over the resources available to the shell and processes\0A    it creates, on systems that allow such control.\0A    \0A    Options:\0A      -S\09use the `soft' resource limit\0A      -H\09use the `hard' resource limit\0A      -a\09all current limits are reported\0A      -b\09the socket buffer size\0A      -c\09the maximum size of core files created\0A      -d\09the maximum size of a process's data segment\0A      -e\09the maximum scheduling priority (`nice')\0A      -f\09the maximum size of files written by the shell and its children\0A      -i\09the maximum number of pending signals\0A      -k\09the maximum number of kqueues allocated for this process\0A      -l\09the maximum size a process may lock into memory\0A      -m\09the maximum resident set size\0A      -n\09the maximum number of open file descriptors\0A      -p\09the pipe buffer size\0A      -q\09the maximum number of bytes in POSIX message queues\0A      -r\09the maximum real-time scheduling priority\0A      -s\09the maximum stack size\0A      -t\09the maximum amount of cpu time in seconds\0A      -u\09the maximum number of user processes\0A      -v\09the size of virtual memory\0A      -x\09the maximum number of file locks\0A      -P\09the maximum number of pseudoterminals\0A      -T\09the maximum number of threads\0A    \0A    Not all options are available on all platforms.\0A    \0A    If LIMIT is given, it is the new value of the specified resource; the\0A    special LIMIT values `soft', `hard', and `unlimited' stand for the\0A    current soft limit, the current hard limit, and no limit, respectively.\0A    Otherwise, the current value of the specified resource is printed.  If\0A    no option is given, then -f is assumed.\0A    \0A    Values are in 1024-byte increments, except for -t, which is in seconds,\0A    -p, which is in increments of 512 bytes, and -u, which is an unscaled\0A    number of processes.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied or an error occurs.\00", align 1
@ulimit_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1936 x i8], [1936 x i8]* @.str.223, i32 0, i32 0), i8* null], align 4
@.str.225 = private unnamed_addr constant [556 x i8] c"Display or set file mode mask.\0A    \0A    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\0A    the current value of the mask.\0A    \0A    If MODE begins with a digit, it is interpreted as an octal number;\0A    otherwise it is a symbolic mode string like that accepted by chmod(1).\0A    \0A    Options:\0A      -p\09if MODE is omitted, output in a form that may be reused as input\0A      -S\09makes the output symbolic; otherwise an octal number is output\0A    \0A    Exit Status:\0A    Returns success unless MODE is invalid or an invalid option is given.\00", align 1
@umask_doc = constant [2 x i8*] [i8* getelementptr inbounds ([556 x i8], [556 x i8]* @.str.225, i32 0, i32 0), i8* null], align 4
@.str.227 = private unnamed_addr constant [395 x i8] c"Wait for process completion and return exit status.\0A    \0A    Waits for each process specified by a PID and reports its termination status.\0A    If PID is not given, waits for all currently active child processes,\0A    and the return status is zero.  PID must be a process ID.\0A    \0A    Exit Status:\0A    Returns the status of the last PID; fails if PID is invalid or an invalid\0A    option is given.\00", align 1
@wait_doc = constant [2 x i8*] [i8* getelementptr inbounds ([395 x i8], [395 x i8]* @.str.227, i32 0, i32 0), i8* null], align 4
@.str.229 = private unnamed_addr constant [374 x i8] c"Execute commands for each member in a list.\0A    \0A    The `for' loop executes a sequence of commands for each member in a\0A    list of items.  If `in WORDS ...;' is not present, then `in \22$@\22' is\0A    assumed.  For each element in WORDS, NAME is set to that element, and\0A    the COMMANDS are executed.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@for_doc = constant [2 x i8*] [i8* getelementptr inbounds ([374 x i8], [374 x i8]* @.str.229, i32 0, i32 0), i8* null], align 4
@.str.231 = private unnamed_addr constant [327 x i8] c"Arithmetic for loop.\0A    \0A    Equivalent to\0A    \09(( EXP1 ))\0A    \09while (( EXP2 )); do\0A    \09\09COMMANDS\0A    \09\09(( EXP3 ))\0A    \09done\0A    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\0A    omitted, it behaves as if it evaluates to 1.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@arith_for_doc = constant [2 x i8*] [i8* getelementptr inbounds ([327 x i8], [327 x i8]* @.str.231, i32 0, i32 0), i8* null], align 4
@.str.233 = private unnamed_addr constant [831 x i8] c"Select words from a list and execute commands.\0A    \0A    The WORDS are expanded, generating a list of words.  The\0A    set of expanded words is printed on the standard error, each\0A    preceded by a number.  If `in WORDS' is not present, `in \22$@\22'\0A    is assumed.  The PS3 prompt is then displayed and a line read\0A    from the standard input.  If the line consists of the number\0A    corresponding to one of the displayed words, then NAME is set\0A    to that word.  If the line is empty, WORDS and the prompt are\0A    redisplayed.  If EOF is read, the command completes.  Any other\0A    value read causes NAME to be set to null.  The line read is saved\0A    in the variable REPLY.  COMMANDS are executed after each selection\0A    until a break command is executed.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@select_doc = constant [2 x i8*] [i8* getelementptr inbounds ([831 x i8], [831 x i8]* @.str.233, i32 0, i32 0), i8* null], align 4
@.str.235 = private unnamed_addr constant [429 x i8] c"Report time consumed by pipeline's execution.\0A    \0A    Execute PIPELINE and print a summary of the real time, user CPU time,\0A    and system CPU time spent executing PIPELINE when it terminates.\0A    \0A    Options:\0A      -p\09print the timing summary in the portable Posix format\0A    \0A    The value of the TIMEFORMAT variable is used as the output format.\0A    \0A    Exit Status:\0A    The return status is the return status of PIPELINE.\00", align 1
@time_doc = constant [2 x i8*] [i8* getelementptr inbounds ([429 x i8], [429 x i8]* @.str.235, i32 0, i32 0), i8* null], align 4
@.str.237 = private unnamed_addr constant [243 x i8] c"Execute commands based on pattern matching.\0A    \0A    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\0A    `|' is used to separate multiple patterns.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@case_doc = constant [2 x i8*] [i8* getelementptr inbounds ([243 x i8], [243 x i8]* @.str.237, i32 0, i32 0), i8* null], align 4
@.str.239 = private unnamed_addr constant [616 x i8] c"Execute commands based on conditional.\0A    \0A    The `if COMMANDS' list is executed.  If its exit status is zero, then the\0A    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\0A    executed in turn, and if its exit status is zero, the corresponding\0A    `then COMMANDS' list is executed and the if command completes.  Otherwise,\0A    the `else COMMANDS' list is executed, if present.  The exit status of the\0A    entire construct is the exit status of the last command executed, or zero\0A    if no condition tested true.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@if_doc = constant [2 x i8*] [i8* getelementptr inbounds ([616 x i8], [616 x i8]* @.str.239, i32 0, i32 0), i8* null], align 4
@.str.241 = private unnamed_addr constant [242 x i8] c"Execute commands as long as a test succeeds.\0A    \0A    Expand and execute COMMANDS as long as the final command in the\0A    `while' COMMANDS has an exit status of zero.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@while_doc = constant [2 x i8*] [i8* getelementptr inbounds ([242 x i8], [242 x i8]* @.str.241, i32 0, i32 0), i8* null], align 4
@.str.243 = private unnamed_addr constant [260 x i8] c"Execute commands as long as a test does not succeed.\0A    \0A    Expand and execute COMMANDS as long as the final command in the\0A    `until' COMMANDS has an exit status which is not zero.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@until_doc = constant [2 x i8*] [i8* getelementptr inbounds ([260 x i8], [260 x i8]* @.str.243, i32 0, i32 0), i8* null], align 4
@.str.245 = private unnamed_addr constant [366 x i8] c"Create a coprocess named NAME.\0A    \0A    Execute COMMAND asynchronously, with the standard output and standard\0A    input of the command connected via a pipe to file descriptors assigned\0A    to indices 0 and 1 of an array variable NAME in the executing shell.\0A    The default NAME is \22COPROC\22.\0A    \0A    Exit Status:\0A    The coproc command returns an exit status of 0.\00", align 1
@coproc_doc = constant [2 x i8*] [i8* getelementptr inbounds ([366 x i8], [366 x i8]* @.str.245, i32 0, i32 0), i8* null], align 4
@.str.247 = private unnamed_addr constant [350 x i8] c"Define shell function.\0A    \0A    Create a shell function named NAME.  When invoked as a simple command,\0A    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\0A    the arguments are passed to the function as $1...$n, and the function's\0A    name is in $FUNCNAME.\0A    \0A    Exit Status:\0A    Returns success unless NAME is readonly.\00", align 1
@function_doc = constant [2 x i8*] [i8* getelementptr inbounds ([350 x i8], [350 x i8]* @.str.247, i32 0, i32 0), i8* null], align 4
@.str.249 = private unnamed_addr constant [204 x i8] c"Group commands as a unit.\0A    \0A    Run a set of commands in a group.  This is one way to redirect an\0A    entire set of commands.\0A    \0A    Exit Status:\0A    Returns the status of the last command executed.\00", align 1
@grouping_braces_doc = constant [2 x i8*] [i8* getelementptr inbounds ([204 x i8], [204 x i8]* @.str.249, i32 0, i32 0), i8* null], align 4
@.str.251 = private unnamed_addr constant [402 x i8] c"Resume job in foreground.\0A    \0A    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\0A    stopped or background job.  JOB_SPEC can specify either a job name\0A    or a job number.  Following JOB_SPEC with a `&' places the job in\0A    the background, as if the job specification had been supplied as an\0A    argument to `bg'.\0A    \0A    Exit Status:\0A    Returns the status of the resumed job.\00", align 1
@fg_percent_doc = constant [2 x i8*] [i8* getelementptr inbounds ([402 x i8], [402 x i8]* @.str.251, i32 0, i32 0), i8* null], align 4
@.str.253 = private unnamed_addr constant [243 x i8] c"Evaluate arithmetic expression.\0A    \0A    The EXPRESSION is evaluated according to the rules for arithmetic\0A    evaluation.  Equivalent to \22let EXPRESSION\22.\0A    \0A    Exit Status:\0A    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise.\00", align 1
@arith_doc = constant [2 x i8*] [i8* getelementptr inbounds ([243 x i8], [243 x i8]* @.str.253, i32 0, i32 0), i8* null], align 4
@.str.255 = private unnamed_addr constant [984 x i8] c"Execute conditional command.\0A    \0A    Returns a status of 0 or 1 depending on the evaluation of the conditional\0A    expression EXPRESSION.  Expressions are composed of the same primaries used\0A    by the `test' builtin, and may be combined using the following operators:\0A    \0A      ( EXPRESSION )\09Returns the value of EXPRESSION\0A      ! EXPRESSION\09\09True if EXPRESSION is false; else false\0A      EXPR1 && EXPR2\09True if both EXPR1 and EXPR2 are true; else false\0A      EXPR1 || EXPR2\09True if either EXPR1 or EXPR2 is true; else false\0A    \0A    When the `==' and `!=' operators are used, the string to the right of\0A    the operator is used as a pattern and pattern matching is performed.\0A    When the `=~' operator is used, the string to the right of the operator\0A    is matched as a regular expression.\0A    \0A    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\0A    determine the expression's value.\0A    \0A    Exit Status:\0A    0 or 1 depending on value of EXPRESSION.\00", align 1
@conditional_doc = constant [2 x i8*] [i8* getelementptr inbounds ([984 x i8], [984 x i8]* @.str.255, i32 0, i32 0), i8* null], align 4
@.str.257 = private unnamed_addr constant [2748 x i8] c"Common shell variable names and usage.\0A    \0A    BASH_VERSION\09Version information for this Bash.\0A    CDPATH\09A colon-separated list of directories to search\0A    \09\09for directories given as arguments to `cd'.\0A    GLOBIGNORE\09A colon-separated list of patterns describing filenames to\0A    \09\09be ignored by pathname expansion.\0A    HISTFILE\09The name of the file where your command history is stored.\0A    HISTFILESIZE\09The maximum number of lines this file can contain.\0A    HISTSIZE\09The maximum number of history lines that a running\0A    \09\09shell can access.\0A    HOME\09The complete pathname to your login directory.\0A    HOSTNAME\09The name of the current host.\0A    HOSTTYPE\09The type of CPU this version of Bash is running under.\0A    IGNOREEOF\09Controls the action of the shell on receipt of an EOF\0A    \09\09character as the sole input.  If set, then the value\0A    \09\09of it is the number of EOF characters that can be seen\0A    \09\09in a row on an empty line before the shell will exit\0A    \09\09(default 10).  When unset, EOF signifies the end of input.\0A    MACHTYPE\09A string describing the current system Bash is running on.\0A    MAILCHECK\09How often, in seconds, Bash checks for new mail.\0A    MAILPATH\09A colon-separated list of filenames which Bash checks\0A    \09\09for new mail.\0A    OSTYPE\09The version of Unix this version of Bash is running on.\0A    PATH\09A colon-separated list of directories to search when\0A    \09\09looking for commands.\0A    PROMPT_COMMAND\09A command to be executed before the printing of each\0A    \09\09primary prompt.\0A    PS1\09\09The primary prompt string.\0A    PS2\09\09The secondary prompt string.\0A    PWD\09\09The full pathname of the current directory.\0A    SHELLOPTS\09A colon-separated list of enabled shell options.\0A    TERM\09The name of the current terminal type.\0A    TIMEFORMAT\09The output format for timing statistics displayed by the\0A    \09\09`time' reserved word.\0A    auto_resume\09Non-null means a command word appearing on a line by\0A    \09\09itself is first looked for in the list of currently\0A    \09\09stopped jobs.  If found there, that job is foregrounded.\0A    \09\09A value of `exact' means that the command word must\0A    \09\09exactly match a command in the list of stopped jobs.  A\0A    \09\09value of `substring' means that the command word must\0A    \09\09match a substring of the job.  Any other value means that\0A    \09\09the command must be a prefix of a stopped job.\0A    histchars\09Characters controlling history expansion and quick\0A    \09\09substitution.  The first character is the history\0A    \09\09substitution character, usually `!'.  The second is\0A    \09\09the `quick substitution' character, usually `^'.  The\0A    \09\09third is the `history comment' character, usually `#'.\0A    HISTIGNORE\09A colon-separated list of patterns used to decide which\0A    \09\09commands should be saved on the history list.\0A\00", align 1
@variable_help_doc = constant [2 x i8*] [i8* getelementptr inbounds ([2748 x i8], [2748 x i8]* @.str.257, i32 0, i32 0), i8* null], align 4
@.str.259 = private unnamed_addr constant [998 x i8] c"Add directories to stack.\0A    \0A    Adds a directory to the top of the directory stack, or rotates\0A    the stack, making the new top of the stack the current working\0A    directory.  With no arguments, exchanges the top two directories.\0A    \0A    Options:\0A      -n\09Suppresses the normal change of directory when adding\0A    \09\09directories to the stack, so only the stack is manipulated.\0A    \0A    Arguments:\0A      +N\09Rotates the stack so that the Nth directory (counting\0A    \09\09from the left of the list shown by `dirs', starting with\0A    \09\09zero) is at the top.\0A    \0A      -N\09Rotates the stack so that the Nth directory (counting\0A    \09\09from the right of the list shown by `dirs', starting with\0A    \09\09zero) is at the top.\0A    \0A      dir\09Adds DIR to the directory stack at the top, making it the\0A    \09\09new current working directory.\0A    \0A    The `dirs' builtin displays the directory stack.\0A    \0A    Exit Status:\0A    Returns success unless an invalid argument is supplied or the directory\0A    change fails.\00", align 1
@pushd_doc = constant [2 x i8*] [i8* getelementptr inbounds ([998 x i8], [998 x i8]* @.str.259, i32 0, i32 0), i8* null], align 4
@.str.261 = private unnamed_addr constant [922 x i8] c"Remove directories from stack.\0A    \0A    Removes entries from the directory stack.  With no arguments, removes\0A    the top directory from the stack, and changes to the new top directory.\0A    \0A    Options:\0A      -n\09Suppresses the normal change of directory when removing\0A    \09\09directories from the stack, so only the stack is manipulated.\0A    \0A    Arguments:\0A      +N\09Removes the Nth entry counting from the left of the list\0A    \09\09shown by `dirs', starting with zero.  For example: `popd +0'\0A    \09\09removes the first directory, `popd +1' the second.\0A    \0A      -N\09Removes the Nth entry counting from the right of the list\0A    \09\09shown by `dirs', starting with zero.  For example: `popd -0'\0A    \09\09removes the last directory, `popd -1' the next to last.\0A    \0A    The `dirs' builtin displays the directory stack.\0A    \0A    Exit Status:\0A    Returns success unless an invalid argument is supplied or the directory\0A    change fails.\00", align 1
@popd_doc = constant [2 x i8*] [i8* getelementptr inbounds ([922 x i8], [922 x i8]* @.str.261, i32 0, i32 0), i8* null], align 4
@.str.263 = private unnamed_addr constant [985 x i8] c"Display directory stack.\0A    \0A    Display the list of currently remembered directories.  Directories\0A    find their way onto the list with the `pushd' command; you can get\0A    back up through the list with the `popd' command.\0A    \0A    Options:\0A      -c\09clear the directory stack by deleting all of the elements\0A      -l\09do not print tilde-prefixed versions of directories relative\0A    \09\09to your home directory\0A      -p\09print the directory stack with one entry per line\0A      -v\09print the directory stack with one entry per line prefixed\0A    \09\09with its position in the stack\0A    \0A    Arguments:\0A      +N\09Displays the Nth entry counting from the left of the list\0A    \09\09shown by dirs when invoked without options, starting with\0A    \09\09zero.\0A    \0A      -N\09Displays the Nth entry counting from the right of the list\0A    \09\09shown by dirs when invoked without options, starting with\0A    \09\09zero.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied or an error occurs.\00", align 1
@dirs_doc = constant [2 x i8*] [i8* getelementptr inbounds ([985 x i8], [985 x i8]* @.str.263, i32 0, i32 0), i8* null], align 4
@.str.265 = private unnamed_addr constant [576 x i8] c"Set and unset shell options.\0A    \0A    Change the setting of each shell option OPTNAME.  Without any option\0A    arguments, list all shell options with an indication of whether or not each\0A    is set.\0A    \0A    Options:\0A      -o\09restrict OPTNAMEs to those defined for use with `set -o'\0A      -p\09print each shell option with an indication of its status\0A      -q\09suppress output\0A      -s\09enable (set) each OPTNAME\0A      -u\09disable (unset) each OPTNAME\0A    \0A    Exit Status:\0A    Returns success if OPTNAME is enabled; fails if an invalid option is\0A    given or OPTNAME is disabled.\00", align 1
@shopt_doc = constant [2 x i8*] [i8* getelementptr inbounds ([576 x i8], [576 x i8]* @.str.265, i32 0, i32 0), i8* null], align 4
@.str.267 = private unnamed_addr constant [1249 x i8] c"Formats and prints ARGUMENTS under control of the FORMAT.\0A    \0A    Options:\0A      -v var\09assign the output to shell variable VAR rather than\0A    \09\09display it on the standard output\0A    \0A    FORMAT is a character string which contains three types of objects: plain\0A    characters, which are simply copied to standard output; character escape\0A    sequences, which are converted and copied to the standard output; and\0A    format specifications, each of which causes printing of the next successive\0A    argument.\0A    \0A    In addition to the standard format specifications described in printf(1),\0A    printf interprets:\0A    \0A      %b\09expand backslash escape sequences in the corresponding argument\0A      %q\09quote the argument in a way that can be reused as shell input\0A      %(fmt)T\09output the date-time string resulting from using FMT as a format\0A    \09        string for strftime(3)\0A    \0A    The format is re-used as necessary to consume all of the arguments.  If\0A    there are fewer arguments than the format requires,  extra format\0A    specifications behave as if a zero value or null string, as appropriate,\0A    had been supplied.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or a write or assignment\0A    error occurs.\00", align 1
@printf_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1249 x i8], [1249 x i8]* @.str.267, i32 0, i32 0), i8* null], align 4
@.str.269 = private unnamed_addr constant [965 x i8] c"Specify how arguments are to be completed by Readline.\0A    \0A    For each NAME, specify how arguments are to be completed.  If no options\0A    are supplied, existing completion specifications are printed in a way that\0A    allows them to be reused as input.\0A    \0A    Options:\0A      -p\09print existing completion specifications in a reusable format\0A      -r\09remove a completion specification for each NAME, or, if no\0A    \09\09NAMEs are supplied, all completion specifications\0A      -D\09apply the completions and actions as the default for commands\0A    \09\09without any specific completion defined\0A      -E\09apply the completions and actions to \22empty\22 commands --\0A    \09\09completion attempted on a blank line\0A    \0A    When completion is attempted, the actions are applied in the order the\0A    uppercase-letter options are listed above.  The -D option takes\0A    precedence over -E.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied or an error occurs.\00", align 1
@complete_doc = constant [2 x i8*] [i8* getelementptr inbounds ([965 x i8], [965 x i8]* @.str.269, i32 0, i32 0), i8* null], align 4
@.str.271 = private unnamed_addr constant [333 x i8] c"Display possible completions depending on the options.\0A    \0A    Intended to be used from within a shell function generating possible\0A    completions.  If the optional WORD argument is supplied, matches against\0A    WORD are generated.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied or an error occurs.\00", align 1
@compgen_doc = constant [2 x i8*] [i8* getelementptr inbounds ([333 x i8], [333 x i8]* @.str.271, i32 0, i32 0), i8* null], align 4
@.str.273 = private unnamed_addr constant [1040 x i8] c"Modify or display completion options.\0A    \0A    Modify the completion options for each NAME, or, if no NAMEs are supplied,\0A    the completion currently being executed.  If no OPTIONs are given, print\0A    the completion options for each NAME or the current completion specification.\0A    \0A    Options:\0A    \09-o option\09Set completion option OPTION for each NAME\0A    \09-D\09\09Change options for the \22default\22 command completion\0A    \09-E\09\09Change options for the \22empty\22 command completion\0A    \0A    Using `+o' instead of `-o' turns off the specified option.\0A    \0A    Arguments:\0A    \0A    Each NAME refers to a command for which a completion specification must\0A    have previously been defined using the `complete' builtin.  If no NAMEs\0A    are supplied, compopt must be called by a function currently generating\0A    completions, and the options for that currently-executing completion\0A    generator are modified.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is supplied or NAME does not\0A    have a completion specification defined.\00", align 1
@compopt_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1040 x i8], [1040 x i8]* @.str.273, i32 0, i32 0), i8* null], align 4
@.str.275 = private unnamed_addr constant [1401 x i8] c"Read lines from the standard input into an indexed array variable.\0A    \0A    Read lines from the standard input into the indexed array variable ARRAY, or\0A    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\0A    is the default ARRAY.\0A    \0A    Options:\0A      -d delim\09Use DELIM to terminate lines, instead of newline\0A      -n count\09Copy at most COUNT lines.  If COUNT is 0, all lines are copied\0A      -O origin\09Begin assigning to ARRAY at index ORIGIN.  The default index is 0\0A      -s count\09Discard the first COUNT lines read\0A      -t\09Remove a trailing DELIM from each line read (default newline)\0A      -u fd\09Read lines from file descriptor FD instead of the standard input\0A      -C callback\09Evaluate CALLBACK each time QUANTUM lines are read\0A      -c quantum\09Specify the number of lines read between each call to\0A    \09\09\09CALLBACK\0A    \0A    Arguments:\0A      ARRAY\09Array variable name to use for file data\0A    \0A    If -C is supplied without -c, the default quantum is 5000.  When\0A    CALLBACK is evaluated, it is supplied the index of the next array\0A    element to be assigned and the line to be assigned to that element\0A    as additional arguments.\0A    \0A    If not supplied with an explicit origin, mapfile will clear ARRAY before\0A    assigning to it.\0A    \0A    Exit Status:\0A    Returns success unless an invalid option is given or ARRAY is readonly or\0A    not an indexed array.\00", align 1
@mapfile_doc = constant [2 x i8*] [i8* getelementptr inbounds ([1401 x i8], [1401 x i8]* @.str.275, i32 0, i32 0), i8* null], align 4
@.str.277 = private unnamed_addr constant [81 x i8] c"Read lines from a file into an array variable.\0A    \0A    A synonym for `mapfile'.\00", align 1
@readarray_doc = constant [2 x i8*] [i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.277, i32 0, i32 0), i8* null], align 4
@current_builtin = common global %struct.builtin* null, align 4

declare i32 @alias_builtin(%struct.word_list*) #0

declare i32 @unalias_builtin(%struct.word_list*) #0

declare i32 @bind_builtin(%struct.word_list*) #0

declare i32 @break_builtin(%struct.word_list*) #0

declare i32 @continue_builtin(%struct.word_list*) #0

declare i32 @builtin_builtin(%struct.word_list*) #0

declare i32 @caller_builtin(%struct.word_list*) #0

declare i32 @cd_builtin(%struct.word_list*) #0

declare i32 @pwd_builtin(%struct.word_list*) #0

declare i32 @colon_builtin(%struct.word_list*) #0

declare i32 @false_builtin(%struct.word_list*) #0

declare i32 @command_builtin(%struct.word_list*) #0

declare i32 @declare_builtin(%struct.word_list*) #0

declare i32 @local_builtin(%struct.word_list*) #0

declare i32 @echo_builtin(%struct.word_list*) #0

declare i32 @enable_builtin(%struct.word_list*) #0

declare i32 @eval_builtin(%struct.word_list*) #0

declare i32 @getopts_builtin(%struct.word_list*) #0

declare i32 @exec_builtin(%struct.word_list*) #0

declare i32 @exit_builtin(%struct.word_list*) #0

declare i32 @logout_builtin(%struct.word_list*) #0

declare i32 @fc_builtin(%struct.word_list*) #0

declare i32 @hash_builtin(%struct.word_list*) #0

declare i32 @help_builtin(%struct.word_list*) #0

declare i32 @history_builtin(%struct.word_list*) #0

declare i32 @kill_builtin(%struct.word_list*) #0

declare i32 @let_builtin(%struct.word_list*) #0

declare i32 @read_builtin(%struct.word_list*) #0

declare i32 @return_builtin(%struct.word_list*) #0

declare i32 @set_builtin(%struct.word_list*) #0

declare i32 @unset_builtin(%struct.word_list*) #0

declare i32 @export_builtin(%struct.word_list*) #0

declare i32 @readonly_builtin(%struct.word_list*) #0

declare i32 @shift_builtin(%struct.word_list*) #0

declare i32 @source_builtin(%struct.word_list*) #0

declare i32 @test_builtin(%struct.word_list*) #0

declare i32 @times_builtin(%struct.word_list*) #0

declare i32 @trap_builtin(%struct.word_list*) #0

declare i32 @type_builtin(%struct.word_list*) #0

declare i32 @ulimit_builtin(%struct.word_list*) #0

declare i32 @umask_builtin(%struct.word_list*) #0

declare i32 @wait_builtin(%struct.word_list*) #0

declare i32 @pushd_builtin(%struct.word_list*) #0

declare i32 @popd_builtin(%struct.word_list*) #0

declare i32 @dirs_builtin(%struct.word_list*) #0

declare i32 @shopt_builtin(%struct.word_list*) #0

declare i32 @printf_builtin(%struct.word_list*) #0

declare i32 @complete_builtin(%struct.word_list*) #0

declare i32 @compgen_builtin(%struct.word_list*) #0

declare i32 @compopt_builtin(%struct.word_list*) #0

declare i32 @mapfile_builtin(%struct.word_list*) #0

attributes #0 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"clang version 4.0.0  (emscripten 1.37.22 : 1.37.22)"}
